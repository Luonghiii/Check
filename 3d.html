<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kh√¥ng gian 3D - ƒêi·ªÅu khi·ªÉn b·∫±ng C·ª≠ ch·ªâ Tay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #video {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            border: 3px solid #00ff88;
            border-radius: 15px;
            transform: scaleX(-1);
            z-index: 10;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        #controls-info {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            color: #fff;
            font-size: 14px;
            z-index: 10;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }

        #controls-info h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 18px;
        }

        #controls-info .control-item {
            margin: 10px 0;
            padding: 8px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 8px;
            border-left: 3px solid #00ff88;
        }

        #controls-info .control-item strong {
            color: #00ffff;
            display: block;
            margin-bottom: 5px;
        }

        #gesture-status {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 136, 0.9);
            color: #000;
            padding: 15px 30px;
            border-radius: 30px;
            font-weight: bold;
            font-size: 18px;
            z-index: 10;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            min-width: 200px;
            text-align: center;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            color: #00ff88;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0, 255, 136, 0.3);
            border-top-color: #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hide {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p style="font-size: 20px;">ƒêang kh·ªüi ƒë·ªông camera...</p>
    </div>

    <div id="canvas-container"></div>
    <video id="video" autoplay playsinline></video>
    <canvas id="hand-canvas" style="display: none;"></canvas>

    <div id="controls-info">
        <h3>üéÆ ƒêi·ªÅu khi·ªÉn</h3>
        <div class="control-item" style="background: rgba(255, 215, 0, 0.2); border-left-color: #ffd700;">
            <strong>üëê 2 TAY - ƒêi·ªÅu khi·ªÉn qu·∫£ c·∫ßu</strong>
            K√©o r·ªông/thu nh·ªè 2 tay ƒë·ªÉ t√°ch/h·ª£p qu·∫£ c·∫ßu
        </div>
        <div class="control-item">
            <strong>üëå Ch·ª•m 2 ng√≥n (1 tay)</strong>
            Ch·ªçn & t∆∞∆°ng t√°c v·∫≠t th·ªÉ
        </div>
        <div class="control-item">
            <strong>‚úã B√†n tay m·ªü (1 tay)</strong>
            Xoay camera xung quanh
        </div>
        <div class="control-item">
            <strong>üëÜ Vu·ªët l√™n/xu·ªëng (1 tay)</strong>
            Di chuy·ªÉn g·∫ßn/xa
        </div>
    </div>

    <div id="gesture-status">S·∫µn s√†ng</div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // Three.js setup
        let scene, camera, renderer, objects = [];
        let selectedObject = null;
        let handX = 0, handY = 0, handZ = 0;
        let prevHandX = 0, prevHandY = 0;
        let isPinching = false;
        let isHandOpen = false;
        
        // Virtual hands (support 2 hands)
        let virtualHands = [null, null];
        let handSpheres = [[], []];
        let handLines = [[], []];
        
        // Tech sphere
        let techSphere = null;
        let sphereParts = [];
        let isSphereExpanded = false;
        let sphereTargetScale = 1;
        let hand1Pos = new THREE.Vector3();
        let hand2Pos = new THREE.Vector3();
        let prevHandDistance = 0;

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0x00ff88, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            const pointLight2 = new THREE.PointLight(0xff0088, 1, 100);
            pointLight2.position.set(-10, -10, 10);
            scene.add(pointLight2);

            // Create tech objects
            createTechObjects();

            // Grid floor
            const gridHelper = new THREE.GridHelper(50, 50, 0x00ff88, 0x004444);
            gridHelper.position.y = -5;
            scene.add(gridHelper);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createTechObjects() {
            // Cube with wireframe
            const cubeGeometry = new THREE.BoxGeometry(2, 2, 2);
            const cubeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff88, 
                emissive: 0x00ff88, 
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.8
            });
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.set(-5, 0, 0);
            
            const wireframe = new THREE.LineSegments(
                new THREE.EdgesGeometry(cubeGeometry),
                new THREE.LineBasicMaterial({ color: 0x00ffff })
            );
            cube.add(wireframe);
            scene.add(cube);
            objects.push(cube);

            // Sphere
            const sphereGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0088,
                emissive: 0xff0088,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(0, 0, 0);
            
            const sphereWireframe = new THREE.LineSegments(
                new THREE.WireframeGeometry(sphereGeometry),
                new THREE.LineBasicMaterial({ color: 0xffff00 })
            );
            sphere.add(sphereWireframe);
            scene.add(sphere);
            objects.push(sphere);

            // Torus
            const torusGeometry = new THREE.TorusGeometry(1.5, 0.5, 16, 100);
            const torusMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.8
            });
            const torus = new THREE.Mesh(torusGeometry, torusMaterial);
            torus.position.set(5, 0, 0);
            torus.rotation.x = Math.PI / 4;
            scene.add(torus);
            objects.push(torus);

            // Pyramid
            const pyramidGeometry = new THREE.ConeGeometry(1.5, 3, 4);
            const pyramidMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffaa00,
                emissive: 0xffaa00,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.8
            });
            const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
            pyramid.position.set(-2.5, 3, -3);
            
            const pyramidWireframe = new THREE.LineSegments(
                new THREE.EdgesGeometry(pyramidGeometry),
                new THREE.LineBasicMaterial({ color: 0xffffff })
            );
            pyramid.add(pyramidWireframe);
            scene.add(pyramid);
            objects.push(pyramid);

            // Octahedron
            const octaGeometry = new THREE.OctahedronGeometry(1.5);
            const octaMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff00ff,
                emissive: 0xff00ff,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.8
            });
            const octa = new THREE.Mesh(octaGeometry, octaMaterial);
            octa.position.set(2.5, 3, -3);
            scene.add(octa);
            objects.push(octa);

            // Floating particles
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCount = 1000;
            const posArray = new Float32Array(particlesCount * 3);
            
            for(let i = 0; i < particlesCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 50;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.05,
                color: 0x00ff88,
                transparent: true,
                opacity: 0.6
            });
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);
            
            // Create tech sphere
            createTechSphere();
        }
        
        function createTechSphere() {
            // Create main sphere group
            techSphere = new THREE.Group();
            techSphere.position.set(0, -2, 0);
            scene.add(techSphere);
            
            // Core sphere
            const coreGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const coreMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0x00ffff,
                emissiveIntensity: 1,
                transparent: true,
                opacity: 0.8
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            techSphere.add(core);
            
            // Create 8 sphere parts that can split
            const partGeometry = new THREE.SphereGeometry(0.8, 16, 16, 0, Math.PI, 0, Math.PI / 2);
            const colors = [0xff0088, 0x00ff88, 0x0088ff, 0xffaa00, 0xff00ff, 0x00ffff, 0xaaff00, 0xff8800];
            
            for (let i = 0; i < 8; i++) {
                const partMaterial = new THREE.MeshPhongMaterial({
                    color: colors[i],
                    emissive: colors[i],
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.7,
                    wireframe: false
                });
                
                const part = new THREE.Mesh(partGeometry, partMaterial);
                
                // Add wireframe
                const wireframeGeo = new THREE.EdgesGeometry(partGeometry);
                const wireframeMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
                const wireframe = new THREE.LineSegments(wireframeGeo, wireframeMat);
                part.add(wireframe);
                
                // Position parts in octant formation
                const angle = (i * Math.PI) / 4;
                part.userData.originalRotation = {
                    x: Math.floor(i / 4) * Math.PI,
                    y: angle,
                    z: 0
                };
                part.rotation.set(part.userData.originalRotation.x, part.userData.originalRotation.y, part.userData.originalRotation.z);
                
                part.userData.index = i;
                techSphere.add(part);
                sphereParts.push(part);
            }
            
            // Add holographic rings
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.TorusGeometry(2 + i * 0.5, 0.02, 16, 100);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.3
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.random() * Math.PI;
                ring.rotation.y = Math.random() * Math.PI;
                techSphere.add(ring);
                ring.userData.isRing = true;
            }
        }
        
        function updateTechSphere() {
            if (!techSphere) return;
            
            // Rotate core and rings
            techSphere.children.forEach((child, index) => {
                if (child.userData.isRing) {
                    child.rotation.z += 0.005;
                } else if (index === 0) {
                    // Core rotation
                    child.rotation.y += 0.01;
                }
            });
            
            // Animate sphere parts based on expansion state
            const targetDistance = isSphereExpanded ? 3 : 0;
            
            sphereParts.forEach((part, i) => {
                const angle = (i * Math.PI) / 4;
                const elevation = Math.floor(i / 4) * Math.PI - Math.PI / 2;
                
                const currentDist = Math.sqrt(
                    part.position.x * part.position.x + 
                    part.position.y * part.position.y + 
                    part.position.z * part.position.z
                );
                
                const newDist = currentDist + (targetDistance - currentDist) * 0.1;
                
                part.position.x = Math.cos(angle) * Math.cos(elevation) * newDist;
                part.position.y = Math.sin(elevation) * newDist;
                part.position.z = Math.sin(angle) * Math.cos(elevation) * newDist;
                
                // Rotate parts
                part.rotation.y += 0.02;
                part.rotation.x += 0.01;
            });
        }

        function createVirtualHand(handIndex) {
            // Create group for hand
            virtualHands[handIndex] = new THREE.Group();
            scene.add(virtualHands[handIndex]);

            // Create 21 spheres for hand landmarks
            for (let i = 0; i < 21; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 16, 16);
                let color = handIndex === 0 ? 0x00ff88 : 0xff0088;
                
                // Different colors for different parts
                if (i === 4) color = handIndex === 0 ? 0xff0088 : 0xffaa00; // Thumb tip
                if (i === 8) color = handIndex === 0 ? 0x00ffff : 0xff00ff; // Index tip
                if (i === 0) color = handIndex === 0 ? 0xffaa00 : 0x00aaff; // Wrist
                
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });
                const sphere = new THREE.Mesh(geometry, material);
                virtualHands[handIndex].add(sphere);
                handSpheres[handIndex].push(sphere);
            }

            // Create lines connecting hand landmarks
            const handConnections = [
                // Thumb
                [0, 1], [1, 2], [2, 3], [3, 4],
                // Index
                [0, 5], [5, 6], [6, 7], [7, 8],
                // Middle
                [0, 9], [9, 10], [10, 11], [11, 12],
                // Ring
                [0, 13], [13, 14], [14, 15], [15, 16],
                // Pinky
                [0, 17], [17, 18], [18, 19], [19, 20],
                // Palm
                [5, 9], [9, 13], [13, 17]
            ];

            handConnections.forEach(() => {
                const geometry = new THREE.BufferGeometry();
                const material = new THREE.LineBasicMaterial({ 
                    color: handIndex === 0 ? 0x00ff88 : 0xff0088,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 2
                });
                const line = new THREE.Line(geometry, material);
                virtualHands[handIndex].add(line);
                handLines[handIndex].push(line);
            });
        }

        function updateVirtualHand(landmarks, handIndex) {
            if (!virtualHands[handIndex]) {
                createVirtualHand(handIndex);
            }

            // Update sphere positions
            landmarks.forEach((landmark, i) => {
                if (handSpheres[handIndex][i]) {
                    // Convert normalized coordinates to 3D space
                    handSpheres[handIndex][i].position.x = (landmark.x - 0.5) * 20;
                    handSpheres[handIndex][i].position.y = -(landmark.y - 0.5) * 15;
                    handSpheres[handIndex][i].position.z = -landmark.z * 10 + 5;
                    
                    // Make thumb and index tips glow when pinching
                    if ((i === 4 || i === 8) && isPinching) {
                        handSpheres[handIndex][i].scale.set(1.5, 1.5, 1.5);
                    } else {
                        handSpheres[handIndex][i].scale.set(1, 1, 1);
                    }
                }
            });

            // Update line positions
            const handConnections = [
                [0, 1], [1, 2], [2, 3], [3, 4],
                [0, 5], [5, 6], [6, 7], [7, 8],
                [0, 9], [9, 10], [10, 11], [11, 12],
                [0, 13], [13, 14], [14, 15], [15, 16],
                [0, 17], [17, 18], [18, 19], [19, 20],
                [5, 9], [9, 13], [13, 17]
            ];

            handConnections.forEach((connection, i) => {
                if (handLines[handIndex][i]) {
                    const [start, end] = connection;
                    const positions = new Float32Array([
                        handSpheres[handIndex][start].position.x,
                        handSpheres[handIndex][start].position.y,
                        handSpheres[handIndex][start].position.z,
                        handSpheres[handIndex][end].position.x,
                        handSpheres[handIndex][end].position.y,
                        handSpheres[handIndex][end].position.z
                    ]);
                    handLines[handIndex][i].geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    
                    // Highlight when pinching
                    if (isPinching && (connection[0] === 4 || connection[1] === 4 || connection[0] === 8 || connection[1] === 8)) {
                        handLines[handIndex][i].material.color.setHex(0xffff00);
                        handLines[handIndex][i].material.opacity = 1;
                    } else {
                        handLines[handIndex][i].material.color.setHex(handIndex === 0 ? 0x00ff88 : 0xff0088);
                        handLines[handIndex][i].material.opacity = 0.6;
                    }
                }
            });

            virtualHands[handIndex].visible = true;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotate all objects
            objects.forEach((obj, index) => {
                obj.rotation.x += 0.005 * (index + 1);
                obj.rotation.y += 0.005 * (index + 1);
                
                // Floating animation
                obj.position.y += Math.sin(Date.now() * 0.001 + index) * 0.003;
            });

            // Highlight selected object
            if (selectedObject) {
                selectedObject.scale.set(1.2, 1.2, 1.2);
            }
            
            // Update tech sphere
            updateTechSphere();

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // MediaPipe Hands setup
        const videoElement = document.getElementById('video');
        const gestureStatus = document.getElementById('gesture-status');

        function updateGestureStatus(text) {
            gestureStatus.textContent = text;
        }

        function distance(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            const dz = point1.z - point2.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        function onResults(results) {
            // Hide all hands first
            virtualHands.forEach((hand, index) => {
                if (hand) hand.visible = false;
            });
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const numHands = results.multiHandLandmarks.length;
                
                // Update each detected hand
                for (let handIndex = 0; handIndex < numHands && handIndex < 2; handIndex++) {
                    const landmarks = results.multiHandLandmarks[handIndex];
                    updateVirtualHand(landmarks, handIndex);
                    
                    // Store hand positions (using index finger tip)
                    const indexTip = landmarks[8];
                    const pos = new THREE.Vector3(
                        (indexTip.x - 0.5) * 20,
                        -(indexTip.y - 0.5) * 15,
                        -indexTip.z * 10 + 5
                    );
                    
                    if (handIndex === 0) {
                        hand1Pos.copy(pos);
                    } else {
                        hand2Pos.copy(pos);
                    }
                }
                
                // Two hands gesture control
                if (numHands === 2) {
                    const handDistance = hand1Pos.distanceTo(hand2Pos);
                    
                    // Detect pinch/spread gesture
                    if (prevHandDistance > 0) {
                        const distanceChange = handDistance - prevHandDistance;
                        
                        // Spreading hands apart - expand sphere
                        if (distanceChange > 0.3 && !isSphereExpanded) {
                            isSphereExpanded = true;
                            updateGestureStatus('‚ú® M·ªü r·ªông qu·∫£ c·∫ßu!');
                        }
                        // Bringing hands together - collapse sphere
                        else if (distanceChange < -0.3 && isSphereExpanded) {
                            isSphereExpanded = false;
                            updateGestureStatus('üí´ Thu nh·ªè qu·∫£ c·∫ßu!');
                        }
                        // Show current distance
                        else if (Math.abs(distanceChange) > 0.05) {
                            if (distanceChange > 0) {
                                updateGestureStatus(`üëê ƒêang m·ªü r·ªông... ${handDistance.toFixed(1)}`);
                            } else {
                                updateGestureStatus(`ü§≤ ƒêang thu nh·ªè... ${handDistance.toFixed(1)}`);
                            }
                        }
                    }
                    
                    prevHandDistance = handDistance;
                    
                    // Move tech sphere to center point between hands
                    if (techSphere) {
                        const centerX = (hand1Pos.x + hand2Pos.x) / 2;
                        const centerY = (hand1Pos.y + hand2Pos.y) / 2;
                        const centerZ = (hand1Pos.z + hand2Pos.z) / 2;
                        
                        techSphere.position.x += (centerX - techSphere.position.x) * 0.1;
                        techSphere.position.y += (centerY - techSphere.position.y) * 0.1;
                        techSphere.position.z += (centerZ - techSphere.position.z) * 0.1;
                    }
                }
                // Single hand control (original functionality)
                else if (numHands === 1) {
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // Get key points
                    const thumb = landmarks[4];
                    const index = landmarks[8];
                    const middle = landmarks[12];
                    const ring = landmarks[16];
                    const pinky = landmarks[20];
                    const wrist = landmarks[0];
                    const indexBase = landmarks[5];

                    // Update hand position
                    handX = index.x * 2 - 1;
                    handY = -(index.y * 2 - 1);
                    handZ = index.z;

                    // Detect pinch (thumb + index close)
                    const pinchDistance = distance(thumb, index);
                    const wasPinching = isPinching;
                    isPinching = pinchDistance < 0.05;

                    if (isPinching && !wasPinching) {
                        selectObjectAtPosition();
                        updateGestureStatus('‚úä ƒêang ch·ªçn v·∫≠t th·ªÉ');
                    } else if (!isPinching && wasPinching) {
                        if (selectedObject) {
                            selectedObject.scale.set(1, 1, 1);
                            selectedObject = null;
                        }
                        updateGestureStatus('üëã 1 tay - ƒêi·ªÅu khi·ªÉn th∆∞·ªùng');
                    }

                    // Detect open hand
                    const fingersExtended = [
                        landmarks[8].y < landmarks[6].y,
                        landmarks[12].y < landmarks[10].y,
                        landmarks[16].y < landmarks[14].y,
                        landmarks[20].y < landmarks[18].y
                    ];
                    isHandOpen = fingersExtended.every(f => f);

                    if (isHandOpen && !isPinching) {
                        const deltaX = handX - prevHandX;
                        const deltaY = handY - prevHandY;
                        
                        camera.position.x += deltaX * 5;
                        camera.position.y += deltaY * 5;
                        camera.lookAt(0, 0, 0);
                        
                        updateGestureStatus('üîÑ Xoay camera');
                    }

                    // Swipe gestures
                    const swipeSpeed = handY - prevHandY;
                    if (Math.abs(swipeSpeed) > 0.02 && !isPinching) {
                        camera.position.z -= swipeSpeed * 20;
                        camera.position.z = Math.max(5, Math.min(30, camera.position.z));
                        
                        if (swipeSpeed > 0) {
                            updateGestureStatus('üëÜ Di chuy·ªÉn g·∫ßn');
                        } else {
                            updateGestureStatus('üëá Di chuy·ªÉn xa');
                        }
                    }

                    const swipeHorizontal = handX - prevHandX;
                    if (Math.abs(swipeHorizontal) > 0.02 && !isPinching && !isHandOpen) {
                        camera.position.x += swipeHorizontal * 10;
                        
                        if (swipeHorizontal > 0) {
                            updateGestureStatus('üëâ Di chuy·ªÉn ph·∫£i');
                        } else {
                            updateGestureStatus('üëà Di chuy·ªÉn tr√°i');
                        }
                    }

                    if (isPinching && selectedObject) {
                        selectedObject.position.x = handX * 10;
                        selectedObject.position.y = handY * 5;
                        selectedObject.rotation.y += 0.05;
                        updateGestureStatus('üéØ ƒêang di chuy·ªÉn v·∫≠t th·ªÉ');
                    }

                    prevHandX = handX;
                    prevHandY = handY;
                    
                    // Reset distance tracking for 2-hand mode
                    prevHandDistance = 0;
                }
            } else {
                updateGestureStatus('‚ùå Kh√¥ng ph√°t hi·ªán b√†n tay');
                prevHandDistance = 0;
            }
        }

        function selectObjectAtPosition() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(handX, handY);
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);
            
            if (intersects.length > 0) {
                if (selectedObject) {
                    selectedObject.scale.set(1, 1, 1);
                }
                selectedObject = intersects[0].object;
            }
        }

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2,  // Support 2 hands
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });

        cameraUtils.start().then(() => {
            document.getElementById('loading').classList.add('hide');
        });

        // Initialize Three.js
        initThreeJS();
    </script>
</body>
</html>
