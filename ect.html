<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Tracking + Blink to Click</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
        }

        #loadingScreen {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            color: white;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loadingText {
            font-size: 18px;
            margin-top: 10px;
            text-align: center;
            max-width: 500px;
        }

        #mainApp {
            position: fixed;
            inset: 0;
            display: none;
        }

        #mainApp.active {
            display: block;
        }

        .video-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            z-index: 100;
        }

        #inputVideo {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 15px;
            transform: scaleX(-1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        #outputCanvas {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 15px;
            border: 3px solid rgba(255,255,255,0.3);
        }

        #faceCursor {
            position: fixed;
            width: 50px;
            height: 50px;
            border: 4px solid #00ff88;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9998;
            transition: all 0.1s ease;
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.6);
            background: radial-gradient(circle, rgba(0, 255, 136, 0.3) 0%, transparent 70%);
            display: none;
            transform: translate(-50%, -50%);
        }

        #faceCursor.active {
            display: block;
        }

        #faceCursor.blinking {
            animation: blinkAnimation 0.4s ease;
            border-color: #ff6b6b;
            box-shadow: 0 0 40px rgba(255, 107, 107, 0.9);
        }

        @keyframes blinkAnimation {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(2); }
        }

        #statusPanel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            color: white;
            z-index: 100;
            min-width: 300px;
        }

        #statusPanel h3 {
            color: #00ff88;
            margin-bottom: 18px;
            font-size: 22px;
        }

        .status-item {
            margin: 14px 0;
            font-size: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .status-indicator {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #ff6b6b;
            box-shadow: 0 0 12px rgba(255, 107, 107, 0.5);
        }

        .status-indicator.active {
            background: #00ff88;
            box-shadow: 0 0 12px rgba(0, 255, 136, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        #targetContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: grid;
            grid-template-columns: repeat(3, 160px);
            gap: 25px;
            z-index: 10;
        }

        .target-box {
            width: 160px;
            height: 160px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 52px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .target-box:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
            border-color: #00ff88;
        }

        .target-box.gazed {
            background: rgba(0, 255, 136, 0.25);
            border-color: #00ff88;
            border-width: 4px;
            transform: scale(1.12);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.4);
        }

        .target-box.clicked {
            animation: targetClickAnim 0.6s ease;
        }

        @keyframes targetClickAnim {
            0% { transform: scale(1); }
            25% { transform: scale(0.85); background: rgba(255, 107, 107, 0.5); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        .target-label {
            font-size: 13px;
            color: white;
            margin-top: 12px;
            opacity: 0.8;
            font-weight: 600;
        }

        #instructions {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            color: white;
            padding: 18px 35px;
            border-radius: 12px;
            text-align: center;
            z-index: 100;
            font-size: 15px;
            line-height: 1.6;
        }

        #instructions strong {
            color: #00ff88;
            font-size: 16px;
        }

        #debugPanel {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
            line-height: 1.8;
        }

        .debug-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        .debug-label {
            color: #00ff88;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div class="spinner"></div>
        <div id="loadingText">ƒêang kh·ªüi t·∫°o camera v√† AI model...</div>
    </div>

    <div id="mainApp">
        <div class="video-container">
            <video id="inputVideo" autoplay playsinline muted></video>
            <canvas id="outputCanvas"></canvas>
        </div>

        <div id="faceCursor"></div>

        <div id="statusPanel">
            <h3>üëÅÔ∏è Face Tracking + Blink</h3>
            <div class="status-item">
                <span class="status-indicator" id="faceIndicator"></span>
                <span>Face: <span id="faceStatus">ƒêang t√¨m...</span></span>
            </div>
            <div class="status-item">
                <span class="status-indicator" id="trackingIndicator"></span>
                <span>Tracking: <span id="trackingStatus">Ch·ªù...</span></span>
            </div>
            <div class="status-item">
                <span class="status-indicator" id="blinkIndicator"></span>
                <span>Blinks: <span id="blinkCount">0</span></span>
            </div>
            <div class="status-item">
                <span class="status-indicator" id="fpsIndicator"></span>
                <span>FPS: <span id="fpsDisplay">0</span></span>
            </div>
        </div>

        <div id="targetContainer">
            <div class="target-box" data-id="1">üéØ<div class="target-label">Target 1</div></div>
            <div class="target-box" data-id="2">‚≠ê<div class="target-label">Target 2</div></div>
            <div class="target-box" data-id="3">üíé<div class="target-label">Target 3</div></div>
            <div class="target-box" data-id="4">üé®<div class="target-label">Target 4</div></div>
            <div class="target-box" data-id="5">üöÄ<div class="target-label">Target 5</div></div>
            <div class="target-box" data-id="6">üéµ<div class="target-label">Target 6</div></div>
            <div class="target-box" data-id="7">üåà<div class="target-label">Target 7</div></div>
            <div class="target-box" data-id="8">üî•<div class="target-label">Target 8</div></div>
            <div class="target-box" data-id="9">‚ú®<div class="target-label">Target 9</div></div>
        </div>

        <div id="instructions">
            <strong>üéØ Di chuy·ªÉn khu√¥n m·∫∑t</strong> ƒë·ªÉ ƒëi·ªÅu khi·ªÉn con tr·ªè<br>
            <strong>üòâ Nh√°y m·∫Øt</strong> ƒë·ªÉ click v√†o c√°c √¥
        </div>

        <div id="debugPanel">
            <div class="debug-row">
                <span class="debug-label">Left EAR:</span>
                <span id="leftEAR">--</span>
            </div>
            <div class="debug-row">
                <span class="debug-label">Right EAR:</span>
                <span id="rightEAR">--</span>
            </div>
            <div class="debug-row">
                <span class="debug-label">Avg EAR:</span>
                <span id="avgEAR">--</span>
            </div>
            <div class="debug-row">
                <span class="debug-label">Threshold:</span>
                <span id="earThreshold">0.20</span>
            </div>
        </div>
    </div>

    <script>
        let faceMesh;
        let camera;
        let videoElement;
        let canvasElement;
        let canvasCtx;
        
        // Face tracking
        let faceX = window.innerWidth / 2;
        let faceY = window.innerHeight / 2;
        let smoothFaceX = faceX;
        let smoothFaceY = faceY;
        const SMOOTHING = 0.25;
        const SENSITIVITY = 2.5;
        
        // Blink detection
        let blinkCount = 0;
        let lastBlinkTime = 0;
        let consecutiveBlinkFrames = 0;
        const BLINK_COOLDOWN = 400;
        const BLINK_FRAMES_THRESHOLD = 2;
        let earThreshold = 0.20;
        let earHistory = [];
        const EAR_HISTORY_SIZE = 20;
        
        // FPS
        let fps = 0;
        let lastFrameTime = Date.now();
        let frameCount = 0;

        async function init() {
            try {
                updateLoadingText('üé• ƒêang kh·ªüi ƒë·ªông camera...');
                
                videoElement = document.getElementById('inputVideo');
                canvasElement = document.getElementById('outputCanvas');
                canvasCtx = canvasElement.getContext('2d');
                
                updateLoadingText('ü§ñ ƒêang t·∫£i MediaPipe FaceMesh...');
                
                faceMesh = new FaceMesh({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                    }
                });
                
                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                faceMesh.onResults(onResults);
                
                updateLoadingText('üìπ ƒêang k·∫øt n·ªëi camera...');
                
                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await faceMesh.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                
                await camera.start();
                
                updateLoadingText('‚úÖ S·∫µn s√†ng!');
                await sleep(500);
                
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('mainApp').classList.add('active');
                document.getElementById('faceCursor').classList.add('active');
                
                console.log('‚úÖ Face tracking + blink detection initialized!');
                
            } catch (error) {
                console.error('‚ùå Init error:', error);
                handleError(error);
            }
        }

        function onResults(results) {
            // Clear canvas
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // Draw face mesh
                drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {color: '#00ff8844', lineWidth: 1});
                drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, {color: '#ff6b6b', lineWidth: 2});
                drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, {color: '#ff6b6b', lineWidth: 2});
                
                // Update face tracking
                updateFacePosition(landmarks);
                
                // Detect blink
                detectBlink(landmarks);
                
                // Update status
                document.getElementById('faceStatus').textContent = 'Ph√°t hi·ªán ‚úì';
                document.getElementById('faceIndicator').classList.add('active');
                document.getElementById('trackingStatus').textContent = 'Ho·∫°t ƒë·ªông';
                document.getElementById('trackingIndicator').classList.add('active');
                
            } else {
                document.getElementById('faceStatus').textContent = 'Kh√¥ng th·∫•y';
                document.getElementById('faceIndicator').classList.remove('active');
                document.getElementById('trackingStatus').textContent = 'Ch·ªù m·∫∑t...';
                document.getElementById('trackingIndicator').classList.remove('active');
            }
            
            canvasCtx.restore();
            updateFPS();
        }

        function updateFacePosition(landmarks) {
            // Get nose tip (index 1) for face center
            const noseTip = landmarks[1];
            
            // Convert normalized coordinates to screen space
            const normalizedX = noseTip.x;
            const normalizedY = noseTip.y;
            
            // Invert X for mirror effect
            const invertedX = 1 - normalizedX;
            
            // Map to screen with sensitivity
            faceX = ((invertedX - 0.5) * SENSITIVITY + 0.5) * window.innerWidth;
            faceY = ((normalizedY - 0.5) * SENSITIVITY + 0.5) * window.innerHeight;
            
            // Smooth movement
            smoothFaceX = smoothFaceX * (1 - SMOOTHING) + faceX * SMOOTHING;
            smoothFaceY = smoothFaceY * (1 - SMOOTHING) + faceY * SMOOTHING;
            
            // Clamp to screen
            smoothFaceX = Math.max(0, Math.min(window.innerWidth, smoothFaceX));
            smoothFaceY = Math.max(0, Math.min(window.innerHeight, smoothFaceY));
            
            // Update cursor
            const cursor = document.getElementById('faceCursor');
            cursor.style.left = smoothFaceX + 'px';
            cursor.style.top = smoothFaceY + 'px';
            
            // Check gaze targets
            checkGazeTargets();
        }

        function detectBlink(landmarks) {
            const leftEAR = calculateEAR(landmarks, [
                362, 385, 387, 263, 373, 380  // Left eye
            ]);
            
            const rightEAR = calculateEAR(landmarks, [
                33, 160, 158, 133, 153, 144  // Right eye
            ]);
            
            const avgEAR = (leftEAR + rightEAR) / 2.0;
            
            // Update debug display
            document.getElementById('leftEAR').textContent = leftEAR.toFixed(3);
            document.getElementById('rightEAR').textContent = rightEAR.toFixed(3);
            document.getElementById('avgEAR').textContent = avgEAR.toFixed(3);
            
            // Update EAR history for dynamic threshold
            earHistory.push(avgEAR);
            if (earHistory.length > EAR_HISTORY_SIZE) {
                earHistory.shift();
            }
            
            // Detect blink
            if (avgEAR < earThreshold) {
                consecutiveBlinkFrames++;
            } else {
                if (consecutiveBlinkFrames >= BLINK_FRAMES_THRESHOLD) {
                    onBlinkDetected();
                }
                consecutiveBlinkFrames = 0;
            }
        }

        function calculateEAR(landmarks, indices) {
            const getPoint = (idx) => landmarks[idx];
            
            const distance = (p1, p2) => {
                const dx = (p1.x - p2.x) * videoElement.videoWidth;
                const dy = (p1.y - p2.y) * videoElement.videoHeight;
                return Math.sqrt(dx * dx + dy * dy);
            };
            
            // EAR formula: (||p2-p6|| + ||p3-p5||) / (2 * ||p1-p4||)
            const vertical1 = distance(getPoint(indices[1]), getPoint(indices[5]));
            const vertical2 = distance(getPoint(indices[2]), getPoint(indices[4]));
            const horizontal = distance(getPoint(indices[0]), getPoint(indices[3]));
            
            return (vertical1 + vertical2) / (2.0 * horizontal);
        }

        function onBlinkDetected() {
            const now = Date.now();
            if (now - lastBlinkTime < BLINK_COOLDOWN) return;
            
            lastBlinkTime = now;
            blinkCount++;
            
            console.log('üòâ Blink detected! Count:', blinkCount);
            
            // Update UI
            document.getElementById('blinkCount').textContent = blinkCount;
            document.getElementById('blinkIndicator').classList.add('active');
            setTimeout(() => {
                document.getElementById('blinkIndicator').classList.remove('active');
            }, 200);
            
            // Cursor animation
            const cursor = document.getElementById('faceCursor');
            cursor.classList.add('blinking');
            setTimeout(() => cursor.classList.remove('blinking'), 400);
            
            // Trigger click
            triggerClickAtGaze();
        }

        function checkGazeTargets() {
            const targets = document.querySelectorAll('.target-box');
            
            targets.forEach(target => {
                const rect = target.getBoundingClientRect();
                const isGazed = 
                    smoothFaceX >= rect.left &&
                    smoothFaceX <= rect.right &&
                    smoothFaceY >= rect.top &&
                    smoothFaceY <= rect.bottom;
                
                if (isGazed) {
                    target.classList.add('gazed');
                } else {
                    target.classList.remove('gazed');
                }
            });
        }

        function triggerClickAtGaze() {
            const targets = document.querySelectorAll('.target-box');
            
            targets.forEach(target => {
                const rect = target.getBoundingClientRect();
                const isHit = 
                    smoothFaceX >= rect.left &&
                    smoothFaceX <= rect.right &&
                    smoothFaceY >= rect.top &&
                    smoothFaceY <= rect.bottom;
                
                if (isHit) {
                    target.classList.add('clicked');
                    setTimeout(() => target.classList.remove('clicked'), 600);
                    
                    // Change emoji
                    const emojis = ['üéØ','‚≠ê','üíé','üé®','üöÄ','üéµ','üåà','üî•','‚ú®','üé™','üé≠','üé¨','üéÆ','üèÜ','üí´','üåü','üí•','üéâ','üå∫','ü¶Ñ','üçï','üé∏','üöÅ','‚ö°'];
                    target.firstChild.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                    
                    console.log('üéØ Hit target:', target.dataset.id);
                }
            });
        }

        function updateFPS() {
            frameCount++;
            const now = Date.now();
            
            if (now - lastFrameTime >= 1000) {
                fps = frameCount;
                document.getElementById('fpsDisplay').textContent = fps;
                
                const indicator = document.getElementById('fpsIndicator');
                if (fps >= 20) {
                    indicator.classList.add('active');
                } else {
                    indicator.classList.remove('active');
                }
                
                frameCount = 0;
                lastFrameTime = now;
            }
        }

        function updateLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
        }

        function handleError(error) {
            const errorMessages = {
                'NotAllowedError': 'B·∫°n c·∫ßn cho ph√©p quy·ªÅn truy c·∫≠p camera',
                'NotFoundError': 'Kh√¥ng t√¨m th·∫•y camera',
                'NotReadableError': 'Camera ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng',
                'SecurityError': 'C·∫ßn HTTPS ho·∫∑c localhost'
            };
            
            const msg = errorMessages[error.name] || error.message;
            
            updateLoadingText(`
                <div style="color: #ff6b6b; margin-bottom: 15px;">‚ùå L·ªói</div>
                <div style="font-size: 14px; opacity: 0.9; margin-bottom: 20px;">${msg}</div>
                <button onclick="location.reload()" style="padding: 12px 30px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px;">üîÑ Th·ª≠ l·∫°i</button>
            `);
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
