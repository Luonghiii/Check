<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eye Tracking Control</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/facemesh"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #videoContainer {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 100;
            border: 3px solid rgba(255,255,255,0.3);
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #cursor {
            position: fixed;
            width: 30px;
            height: 30px;
            border: 3px solid #fff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transition: all 0.1s ease;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            display: none;
        }

        #cursor.clicking {
            animation: clickPulse 0.3s ease;
            background: radial-gradient(circle, rgba(255,100,100,0.5) 0%, transparent 70%);
        }

        @keyframes clickPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.5); }
        }

        #status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.95);
            padding: 20px 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        #status h2 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 20px;
        }

        #status p {
            color: #555;
            margin: 5px 0;
            font-size: 14px;
        }

        .indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .indicator.active {
            background: #4ade80;
            box-shadow: 0 0 10px #4ade80;
        }

        .indicator.inactive {
            background: #f87171;
        }

        #playground {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: grid;
            grid-template-columns: repeat(3, 150px);
            gap: 20px;
            z-index: 10;
        }

        .target-box {
            width: 150px;
            height: 150px;
            background: rgba(255,255,255,0.2);
            border: 3px solid rgba(255,255,255,0.4);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .target-box:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .target-box.clicked {
            animation: targetClick 0.5s ease;
        }

        @keyframes targetClick {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(0.9); background: rgba(100,255,100,0.5); }
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 1000;
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>ƒêang t·∫£i m√¥ h√¨nh AI...</p>
        </div>

        <div id="videoContainer" style="display: none;">
            <video id="webcam" autoplay playsinline></video>
        </div>

        <div id="cursor"></div>

        <div id="status" style="display: none;">
            <h2>üëÅÔ∏è Eye Tracking Active</h2>
            <p><span class="indicator inactive" id="trackingIndicator"></span>Tracking: <span id="trackingStatus">Ch·ªù...</span></p>
            <p>üñ±Ô∏è Nh√¨n ƒë·ªÉ di chuy·ªÉn con tr·ªè</p>
            <p>üòâ Nh√°y m·∫Øt ƒë·ªÉ click</p>
            <p>Clicks: <strong id="clickCount">0</strong></p>
        </div>

        <div id="playground" style="display: none;">
            <div class="target-box" data-emoji="üéØ">üéØ</div>
            <div class="target-box" data-emoji="‚≠ê">‚≠ê</div>
            <div class="target-box" data-emoji="üíé">üíé</div>
            <div class="target-box" data-emoji="üé®">üé®</div>
            <div class="target-box" data-emoji="üöÄ">üöÄ</div>
            <div class="target-box" data-emoji="üéµ">üéµ</div>
            <div class="target-box" data-emoji="üåà">üåà</div>
            <div class="target-box" data-emoji="üî•">üî•</div>
            <div class="target-box" data-emoji="‚ú®">‚ú®</div>
        </div>

        <div id="instructions" style="display: none;">
            <strong>H∆∞·ªõng d·∫´n:</strong> Di chuy·ªÉn m·∫Øt ƒë·ªÉ ƒëi·ªÅu khi·ªÉn con tr·ªè | Nh√°y m·∫Øt ƒë·ªÉ click v√†o c√°c √¥
        </div>
    </div>

    <script>
        let model;
        let cursor = document.getElementById('cursor');
        let clickCount = 0;
        let blinkDetected = false;
        let lastBlinkTime = 0;
        const BLINK_THRESHOLD = 3.5; // Ng∆∞·ª°ng t·ª∑ l·ªá EAR
        const BLINK_COOLDOWN = 500; // ms
        let isModelLoaded = false;
        let isVideoReady = false;
        let lastEAR = 10; // Eye Aspect Ratio ban ƒë·∫ßu

        // Kh·ªüi t·∫°o webcam
        async function setupWebcam() {
            console.log('Setting up webcam...');
            const video = document.getElementById('webcam');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: 640, 
                        height: 480,
                        facingMode: 'user'
                    }
                });
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        console.log('Webcam ready');
                        isVideoReady = true;
                        resolve(video);
                    };
                });
            } catch (err) {
                console.error('Webcam error:', err);
                throw new Error('Kh√¥ng th·ªÉ truy c·∫≠p camera. Vui l√≤ng ki·ªÉm tra quy·ªÅn truy c·∫≠p!');
            }
        }

        // Kh·ªüi t·∫°o FaceMesh model
        async function loadModel() {
            console.log('Loading FaceMesh model...');
            document.getElementById('loading').innerHTML = `
                <div class="spinner"></div>
                <p>ƒêang t·∫£i m√¥ h√¨nh AI...</p>
                <p style="font-size: 14px; opacity: 0.7;">C√≥ th·ªÉ m·∫•t 10-30 gi√¢y</p>
            `;
            
            try {
                model = await facemesh.load({
                    maxFaces: 1,
                    detectionConfidence: 0.9,
                    iouThreshold: 0.3,
                    scoreThreshold: 0.75
                });
                console.log('FaceMesh model loaded successfully!');
                isModelLoaded = true;
            } catch (err) {
                console.error('Model loading error:', err);
                throw new Error('Kh√¥ng th·ªÉ t·∫£i m√¥ h√¨nh AI. Vui l√≤ng th·ª≠ l·∫°i!');
            }
        }

        // T√≠nh kho·∫£ng c√°ch gi·ªØa 2 ƒëi·ªÉm
        function distance(point1, point2) {
            return Math.sqrt(
                Math.pow(point1[0] - point2[0], 2) +
                Math.pow(point1[1] - point2[1], 2) +
                Math.pow(point1[2] - point2[2], 2)
            );
        }

        // T√≠nh Eye Aspect Ratio (EAR) ƒë·ªÉ ph√°t hi·ªán nh√°y m·∫Øt
        function calculateEAR(eye) {
            // eye = [p1, p2, p3, p4, p5, p6]
            // p2-p6 v√† p3-p5 l√† chi·ªÅu d·ªçc
            // p1-p4 l√† chi·ªÅu ngang
            const vertical1 = distance(eye[1], eye[5]);
            const vertical2 = distance(eye[2], eye[4]);
            const horizontal = distance(eye[0], eye[3]);
            
            const ear = (vertical1 + vertical2) / (2.0 * horizontal);
            return ear;
        }

        // Ph√°t hi·ªán nh√°y m·∫Øt d·ª±a tr√™n EAR
        function detectBlink(landmarks) {
            // Left eye indices: 33, 160, 158, 133, 153, 144
            // Right eye indices: 362, 385, 387, 263, 373, 380
            
            const leftEye = [
                landmarks[33],  // outer corner
                landmarks[160], // top 1
                landmarks[158], // top 2
                landmarks[133], // inner corner
                landmarks[153], // bottom 1
                landmarks[144]  // bottom 2
            ];
            
            const rightEye = [
                landmarks[362], // outer corner
                landmarks[385], // top 1
                landmarks[387], // top 2
                landmarks[263], // inner corner
                landmarks[373], // bottom 1
                landmarks[380]  // bottom 2
            ];
            
            // Ki·ªÉm tra t·∫•t c·∫£ ƒëi·ªÉm c√≥ t·ªìn t·∫°i
            const allPointsExist = [...leftEye, ...rightEye].every(p => p && p.length >= 3);
            if (!allPointsExist) {
                return false;
            }
            
            const leftEAR = calculateEAR(leftEye);
            const rightEAR = calculateEAR(rightEye);
            const avgEAR = (leftEAR + rightEAR) / 2;
            
            // Debug
            console.log('EAR:', avgEAR.toFixed(3));
            
            // Nh√°y m·∫Øt khi EAR gi·∫£m ƒë·ªôt ng·ªôt
            const earDrop = lastEAR - avgEAR;
            lastEAR = avgEAR;
            
            // N·∫øu EAR gi·∫£m h∆°n 0.05 so v·ªõi tr∆∞·ªõc ƒë√≥ = nh√°y m·∫Øt
            return earDrop > 0.05 && avgEAR < 0.2;
        }

        // Trigger click event
        function triggerClick(x, y) {
            const now = Date.now();
            if (now - lastBlinkTime < BLINK_COOLDOWN) return;
            
            lastBlinkTime = now;
            clickCount++;
            document.getElementById('clickCount').textContent = clickCount;
            
            // Visual feedback
            cursor.classList.add('clicking');
            setTimeout(() => cursor.classList.remove('clicking'), 300);
            
            // Ki·ªÉm tra xem c√≥ click v√†o target box n√†o kh√¥ng
            const boxes = document.querySelectorAll('.target-box');
            boxes.forEach(box => {
                const rect = box.getBoundingClientRect();
                if (x >= rect.left && x <= rect.right && 
                    y >= rect.top && y <= rect.bottom) {
                    box.classList.add('clicked');
                    setTimeout(() => box.classList.remove('clicked'), 500);
                    
                    // Random emoji m·ªõi
                    const emojis = ['üéØ', '‚≠ê', 'üíé', 'üé®', 'üöÄ', 'üéµ', 'üåà', 'üî•', '‚ú®', 'üé™', 'üé≠', 'üé¨', 'üéÆ', 'üèÜ', 'üí´'];
                    box.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                }
            });
        }

        // Detect faces v√† c·∫≠p nh·∫≠t v·ªã tr√≠ cursor
        async function detectFaces() {
            if (!isModelLoaded || !isVideoReady) {
                console.log('Waiting for model and video...');
                setTimeout(detectFaces, 100);
                return;
            }

            const video = document.getElementById('webcam');
            
            try {
                const predictions = await model.estimateFaces(video);
                
                if (predictions.length > 0) {
                    const keypoints = predictions[0].scaledMesh;
                    
                    // S·ª≠ d·ª•ng c√°c ƒëi·ªÉm quanh m·∫Øt ƒë·ªÉ t√≠nh h∆∞·ªõng nh√¨n
                    // Left eye center: 468 (n·∫øu c√≥ iris tracking) ho·∫∑c d√πng 33
                    // Right eye center: 473 ho·∫∑c 263
                    
                    // L·∫•y 4 g√≥c c·ªßa m·ªói m·∫Øt ƒë·ªÉ t√≠nh ƒëi·ªÉm gi·ªØa ch√≠nh x√°c
                    const leftEyeInner = keypoints[133]; // Left inner corner
                    const leftEyeOuter = keypoints[33];  // Left outer corner
                    const rightEyeInner = keypoints[362]; // Right inner corner  
                    const rightEyeOuter = keypoints[263]; // Right outer corner
                    
                    if (!leftEyeInner || !leftEyeOuter || !rightEyeInner || !rightEyeOuter) {
                        requestAnimationFrame(detectFaces);
                        return;
                    }
                    
                    // T√≠nh ƒëi·ªÉm gi·ªØa m·ªói m·∫Øt
                    const leftEyeCenterX = (leftEyeInner[0] + leftEyeOuter[0]) / 2;
                    const leftEyeCenterY = (leftEyeInner[1] + leftEyeOuter[1]) / 2;
                    const rightEyeCenterX = (rightEyeInner[0] + rightEyeOuter[0]) / 2;
                    const rightEyeCenterY = (rightEyeInner[1] + rightEyeOuter[1]) / 2;
                    
                    // T√≠nh ƒëi·ªÉm gi·ªØa 2 m·∫Øt
                    const gazeCenterX = (leftEyeCenterX + rightEyeCenterX) / 2;
                    const gazeCenterY = (leftEyeCenterY + rightEyeCenterY) / 2;
                    
                    // L·∫•y ƒëi·ªÉm m≈©i ƒë·ªÉ l√†m reference
                    const noseTip = keypoints[1]; // Nose tip
                    
                    // T√≠nh offset t·ª´ m≈©i ƒë·∫øn ƒëi·ªÉm gi·ªØa m·∫Øt (h∆∞·ªõng nh√¨n)
                    const gazeOffsetX = gazeCenterX - noseTip[0];
                    const gazeOffsetY = gazeCenterY - noseTip[1];
                    
                    // Map v·ªã tr√≠ t·ª´ video sang m√†n h√¨nh
                    // Video b·ªã mirror n√™n ƒë·∫£o ng∆∞·ª£c X
                    const baseX = window.innerWidth - (gazeCenterX / 640) * window.innerWidth;
                    const baseY = (gazeCenterY / 480) * window.innerHeight;
                    
                    // Th√™m offset d·ª±a tr√™n h∆∞·ªõng nh√¨n (amplify ƒë·ªÉ nh·∫°y h∆°n)
                    const amplifyFactor = 2.0;
                    const screenX = baseX - (gazeOffsetX * amplifyFactor);
                    const screenY = baseY + (gazeOffsetY * amplifyFactor);
                    
                    // Gi·ªõi h·∫°n trong m√†n h√¨nh
                    const clampedX = Math.max(0, Math.min(window.innerWidth, screenX));
                    const clampedY = Math.max(0, Math.min(window.innerHeight, screenY));
                    
                    // C·∫≠p nh·∫≠t v·ªã tr√≠ cursor v·ªõi smooth transition
                    cursor.style.left = clampedX + 'px';
                    cursor.style.top = clampedY + 'px';
                    cursor.style.transform = 'translate(-50%, -50%)';
                    cursor.style.display = 'block';
                    
                    // Ph√°t hi·ªán nh√°y m·∫Øt
                    const isBlink = detectBlink(keypoints);
                    
                    if (isBlink && !blinkDetected) {
                        const now = Date.now();
                        if (now - lastBlinkTime > BLINK_COOLDOWN) {
                            blinkDetected = true;
                            triggerClick(clampedX, clampedY);
                        }
                    } else if (!isBlink) {
                        blinkDetected = false;
                    }
                    
                    // C·∫≠p nh·∫≠t status
                    document.getElementById('trackingStatus').textContent = 'Ho·∫°t ƒë·ªông';
                    document.getElementById('trackingIndicator').className = 'indicator active';
                } else {
                    document.getElementById('trackingStatus').textContent = 'Kh√¥ng ph√°t hi·ªán khu√¥n m·∫∑t';
                    document.getElementById('trackingIndicator').className = 'indicator inactive';
                }
            } catch (err) {
                console.error('Detection error:', err);
                document.getElementById('trackingStatus').textContent = 'L·ªói: ' + err.message;
                document.getElementById('trackingIndicator').className = 'indicator inactive';
            }
            
            requestAnimationFrame(detectFaces);
        }

        // Kh·ªüi ƒë·ªông app
        async function init() {
            try {
                console.log('Initializing app...');
                
                // Step 1: Setup webcam
                console.log('Step 1: Setting up webcam...');
                await setupWebcam();
                document.getElementById('videoContainer').style.display = 'block';
                
                // Step 2: Load model
                console.log('Step 2: Loading AI model...');
                await loadModel();
                
                // Step 3: ·∫®n loading, hi·ªán UI
                console.log('Step 3: Showing UI...');
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').style.display = 'block';
                document.getElementById('playground').style.display = 'grid';
                document.getElementById('instructions').style.display = 'block';
                
                // Step 4: B·∫Øt ƒë·∫ßu detection
                console.log('Step 4: Starting face detection...');
                cursor.style.display = 'none'; // ·∫®n cursor ban ƒë·∫ßu
                detectFaces();
                
                console.log('‚úÖ App initialized successfully!');
            } catch (error) {
                console.error('‚ùå Init error:', error);
                document.getElementById('loading').innerHTML = `
                    <p style="color: #ff6b6b;">‚ùå L·ªói: ${error.message}</p>
                    <p style="font-size: 14px; margin-top: 10px;">Vui l√≤ng:</p>
                    <p style="font-size: 14px;">1. Cho ph√©p truy c·∫≠p camera</p>
                    <p style="font-size: 14px;">2. S·ª≠ d·ª•ng tr√¨nh duy·ªát Chrome/Edge</p>
                    <p style="font-size: 14px;">3. T·∫£i l·∫°i trang (F5)</p>
                    <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px;">T·∫£i l·∫°i trang</button>
                `;
            }
        }

        // Ch·∫°y khi trang load xong
        window.addEventListener('load', () => {
            console.log('Page loaded, starting init...');
            init();
        });
    </script>
</body>
</html>
